use anyhow::anyhow;
use clap::Parser;
use jclassfile::{
    class_file::{self, ClassFile},
    constant_pool::ConstantPool,
};
use mermaid_parser::{parser::parse, types::Diagram};
use std::{
    collections::BTreeMap,
    fs,
    path::{Path, PathBuf},
};

/// This program will take in a list of mermaid files which need "linking"
/// according to some list of targets.
#[derive(clap::Parser)]
pub struct Args {
    /// Some mermaid diagram file, generally containing relationships but
    /// can also have classes. These do not need to end with .mmd and will
    /// be assumed to have valid mermaid.
    target: Vec<PathBuf>,
    /// Files and folders to search for class definitions. Folders will be
    /// searched recursively any folder. These should be java class files.
    #[arg(short, long)]
    include: Vec<PathBuf>,
    /// Directory to write the final files to
    #[arg(short, long)]
    output: PathBuf,
    /// The fully qualified path of the skip annotation to optionally enable
    /// ommiting some types, fields, or methods. (e.g. `com.rocket.radar.Skip`)
    /// Note that this annotation must have a retention policy of RUNTIME
    /// or CLASS.
    #[arg(short, long)]
    skip: Option<String>,
}

#[derive(thiserror::Error, derive_more::From, Debug)]
enum LoadClassError {
    #[error("{0}")]
    Io(std::io::Error),
    #[error("{0}")]
    Parse(jclassfile::error::Error),
}

/// Helper to load a single classfile.
fn load_classfile(path: &Path) -> Result<ClassFile, LoadClassError> {
    let data = std::fs::read(path)?;
    Ok(class_file::parse(&data)?)
}

/// Load classfile for single file and all classfiles recursively if directory.
/// It will only load classfiles with a .class extension. If there is a file
/// with a .class extension which is not parseable as a classfile will issue a
/// warning and continue. All other errors will halt.
///
/// Note that this will skip loading the classfiles for anonymous classes. Such
/// as those generated by lambdas. (These are the classfiles whose names end with
/// $ and some number).
fn load_classfiles(
    store: &mut BTreeMap<String, ClassFile>,
    include_path: &Path,
) -> anyhow::Result<()> {
    if !include_path.exists() {
        return Err(anyhow!(
            "ERROR: Missing include path {}",
            include_path.display()
        ));
    }

    if include_path.is_dir() {
        for entry in include_path.read_dir()? {
            load_classfiles(store, &entry?.path())?;
        }
    } else if include_path.is_file() {
        if include_path
            .extension()
            .map(|ext| ext == "class")
            .unwrap_or(false)
        {
            let mut filestem = include_path
                .file_stem()
                .expect("If we have an ext we should have a stem")
                .to_string_lossy()
                .to_string();

            // Skip this classfile if it has an anonymous class
            if let Some((_, maybe_num)) = filestem.rsplit_once('$') {
                if maybe_num.chars().all(|ch| ch.is_numeric()) {
                    return Ok(());
                }
                // PERF: This is wasteful. We could do better.
                filestem = filestem.replace('$', "_");
            }

            match load_classfile(include_path) {
                Ok(classfile) => {
                    let old = store.insert(filestem, classfile);
                    assert!(old.is_none(), "All the class names should be unique");
                }
                Err(LoadClassError::Parse(why)) => {
                    eprintln!(
                        "WARN: Found an include file with extension .class but failed to parse `{}`\n{}",
                        include_path.display(),
                        why
                    );
                }
                Err(why) => return Err(why.into()),
            }
        }
    } else {
        return Err(anyhow!(
            "Passed an include path that pointed to a symlink ({})",
            include_path.display()
        ));
    }

    Ok(())
}

const FAILED_TO_LOAD_CLASSFILES: i32 = 1;
const FAILED_TO_LOAD_DIAGRAM: i32 = 2;

#[derive(thiserror::Error, derive_more::From, Debug)]
enum LoadMermaidError {
    #[error("{0}")]
    Io(std::io::Error),
    #[error("{0}")]
    Parse(mermaid_parser::parser::ParseError),
}

fn load_mermaid(path: &Path) -> Result<mermaid_parser::types::Diagram, LoadMermaidError> {
    let link_content = fs::read_to_string(path)?;
    Ok(mermaid_parser::parser::parse(&link_content)?)
}

// PERF: This is a hot function, and it gets hotter for large projects.
// probably want it to run fast.
fn try_retrieve(classfiles: &BTreeMap<String, ClassFile>, class_name: &str) {
    for (name, class) in classfiles {
        // SAFETY: Only way this doesn't work is if we are given malformed classfiles.
        let class_name = unsafe {
            let ConstantPool::Class { name_index } = class
                .constant_pool()
                .get_unchecked(class.this_class() as usize)
            else {
                panic!("This is not formed how I expect");
            };
            let ConstantPool::Utf8 { value } =
                class.constant_pool().get_unchecked(*name_index as usize)
            else {
                panic!("This is not formed how I expect");
            };
            value
        };

        println!("filename: {}\n class name: {}\n\n", name, class_name);
    }
}

fn main() {
    let args = Args::parse();

    // Load all relevant classfiles and diagrams. We halt if there is an error.
    let mut classfiles = BTreeMap::<String, ClassFile>::new();
    for include_path in args.include {
        if let Err(why) = load_classfiles(&mut classfiles, &include_path) {
            eprintln!("ERROR: {}", why);
            std::process::exit(FAILED_TO_LOAD_CLASSFILES);
        }
    }

    let mut diagrams = Vec::<Diagram>::with_capacity(args.target.len());
    for target_path in args.target {
        match load_mermaid(&target_path) {
            Ok(diagram) => diagrams.push(diagram),
            Err(why) => {
                eprintln!("ERROR: {}", why);
                std::process::exit(FAILED_TO_LOAD_DIAGRAM);
            }
        }
    }

    let mut outstring = String::new();

    // Now consider each diagram and what is needs to contain.
    for diagram in diagrams {
        outstring.clear();

        for (namepace_name, namespace) in diagram.namespaces {
            for (class_name, class) in namespace.classes {
                try_retrieve(&classfiles, "");
            }
        }

        for relation in diagram.relations {}
    }
}
