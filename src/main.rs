mod classfile_utils;
mod descriptor;

use anyhow::anyhow;
use clap::Parser;
use classfile_utils::{classfile_to_mermaid_class, get_full_class_name, get_package_name};
use jclassfile::class_file::{self, ClassFile};
use mermaid_parser::serializer::serialize_diagram;
use mermaid_parser::types::Diagram;
use std::{
    collections::{BTreeMap, HashSet},
    fs,
    path::{Path, PathBuf},
};

/// This program will take in a list of mermaid files which need "linking"
/// according to some list of targets.
#[derive(clap::Parser)]
pub struct Args {
    /// Some mermaid diagram file, generally containing relationships but
    /// can also have classes. It is basically a starting off point for the
    /// diagram generation.
    diagram: Option<PathBuf>,
    /// Files and folders to search for class definitions. Folders will be
    /// searched recursively any folder. These should be java class files.
    #[arg(short, long)]
    classfiles: Vec<PathBuf>,
    /// Directory or filename for output file. If a directory is given this
    /// will be the same as the input name.
    #[arg(short, long)]
    output: PathBuf,
    /// The fully qualified path of the skip annotation to optionally enable
    /// ommiting some types, fields, or methods. (e.g. `com.rocket.radar.Skip`)
    /// Note that this annotation must have a retention policy of RUNTIME
    /// or CLASS.
    #[arg(long)]
    skip: Option<String>,
    /// Fully qualified path to the aggregate annotation.
    #[arg(long)]
    aggregate: Option<String>,
    /// Fully qualified path to the compose annotation.
    #[arg(long)]
    compose: Option<String>,
    /// Fully qualified path to the link annotation
    #[arg(long)]
    link: Option<String>,
    /// Fully qualified path to the navigate annotation.
    #[arg(long)]
    navigate: Option<String>,
}

#[derive(thiserror::Error, derive_more::From, Debug)]
enum LoadClassError {
    #[error("{0}")]
    Io(std::io::Error),
    #[error("{0}")]
    Parse(jclassfile::error::Error),
}

/// Helper to load a single classfile.
fn load_classfile(path: &Path) -> Result<ClassFile, LoadClassError> {
    let data = std::fs::read(path)?;
    Ok(class_file::parse(&data)?)
}

/// Load classfile for single file and all classfiles recursively if directory.
/// It will only load classfiles with a .class extension. If there is a file
/// with a .class extension which is not parseable as a classfile will issue a
/// warning and continue. All other errors will halt.
///
/// Note that this will skip loading the classfiles for anonymous classes. Such
/// as those generated by lambdas. (These are the classfiles whose names end with
/// $ and some number).
fn load_classfiles(
    store: &mut BTreeMap<String, ClassFile>,
    include_path: &Path,
) -> anyhow::Result<()> {
    if !include_path.exists() {
        return Err(anyhow!(
            "ERROR: Missing include path {}",
            include_path.display()
        ));
    }

    if include_path.is_dir() {
        for entry in include_path.read_dir()? {
            load_classfiles(store, &entry?.path())?;
        }
    } else if include_path.is_file() {
        if include_path
            .extension()
            .map(|ext| ext == "class")
            .unwrap_or(false)
        {
            let mut filestem = include_path
                .file_stem()
                .expect("If we have an ext we should have a stem")
                .to_string_lossy()
                .to_string();

            // Skip this classfile if it has an anonymous class
            if let Some((_, maybe_num)) = filestem.rsplit_once('$') {
                if maybe_num.chars().all(|ch| ch.is_numeric()) {
                    return Ok(());
                }
                // PERF: This is wasteful. We could do better.
                filestem = filestem.replace('$', "_");
            }

            match load_classfile(include_path) {
                Ok(classfile) => {
                    let old = store.insert(filestem, classfile);
                    assert!(old.is_none(), "All the class names should be unique");
                }
                Err(LoadClassError::Parse(why)) => {
                    eprintln!(
                        "WARN: Found an include file with extension .class but failed to parse `{}`\n{}",
                        include_path.display(),
                        why
                    );
                }
                Err(why) => return Err(why.into()),
            }
        }
    } else {
        return Err(anyhow!(
            "Passed an include path that pointed to a symlink ({})",
            include_path.display()
        ));
    }

    Ok(())
}

const FAILED_TO_LOAD_CLASSFILES: i32 = 1;
const FAILED_TO_LOAD_DIAGRAM: i32 = 2;
const FAILED_TO_WRITE_OUTPUT: i32 = 3;

#[derive(thiserror::Error, derive_more::From, Debug)]
enum LoadMermaidError {
    #[error("{0}")]
    Io(std::io::Error),
    #[error("{0}")]
    Parse(mermaid_parser::parser::ParseError),
}

fn load_mermaid(path: &Path) -> Result<mermaid_parser::types::Diagram, LoadMermaidError> {
    let link_content = fs::read_to_string(path)?;
    Ok(mermaid_parser::parser::parse(&link_content)?)
}

/// Collect all class names referenced in the diagram (from stubs and relations)
fn collect_referenced_classes(diagram: &Diagram) -> HashSet<String> {
    let mut referenced = HashSet::new();

    // Add all classes defined in the diagram
    for (_namespace_name, namespace) in &diagram.namespaces {
        for (class_name, _class) in &namespace.classes {
            referenced.insert(class_name.clone());
        }
    }

    // Add all classes referenced in relations
    for relation in &diagram.relations {
        referenced.insert(relation.from.clone());
        referenced.insert(relation.to.clone());
    }

    referenced
}

/// Find the common base package among all classes
/// Returns the common prefix package path (e.g., "com/example")
fn find_common_base_package(packages: &[&str]) -> String {
    if packages.is_empty() {
        return String::new();
    }

    // Split all packages into components
    let split_packages: Vec<Vec<&str>> = packages.iter().map(|p| p.split('/').collect()).collect();

    if split_packages.is_empty() {
        return String::new();
    }

    // Find common prefix
    let mut common = Vec::new();
    let first = &split_packages[0];

    for (i, component) in first.iter().enumerate() {
        if split_packages.iter().all(|p| p.get(i) == Some(component)) {
            common.push(*component);
        } else {
            break;
        }
    }

    common.join("/")
}

/// Convert a full package name to a relative namespace
/// e.g., base="com/example", full="com/example/subpackage" -> "subpackage"
fn get_relative_namespace(base: &str, full: &str) -> String {
    if base.is_empty() {
        return full.replace('/', ".");
    }

    if full == base {
        return mermaid_parser::types::DEFAULT_NAMESPACE.to_string();
    }

    if full.starts_with(base) {
        let relative = &full[base.len()..];
        let relative = relative.trim_start_matches('/');
        if relative.is_empty() {
            mermaid_parser::types::DEFAULT_NAMESPACE.to_string()
        } else {
            relative.replace('/', ".")
        }
    } else {
        full.replace('/', ".")
    }
}

/// Check if groupPackage is enabled in the YAML frontmatter
fn should_group_by_package(diagram: &Diagram) -> bool {
    if let Some(yaml) = &diagram.yaml {
        if let Some(umlink) = yaml.get("umlink") {
            if let Some(group_package) = umlink.get("groupPackage") {
                return group_package.as_bool().unwrap_or(false);
            }
        }
    }
    false
}

fn main() {
    let args = Args::parse();

    // Create output directory if it doesn't exist
    if !args.output.exists() {
        if let Err(why) = fs::create_dir_all(&args.output) {
            eprintln!("ERROR: Failed to create output directory: {}", why);
            std::process::exit(FAILED_TO_WRITE_OUTPUT);
        }
    }

    // Load all relevant classfiles and diagrams. We halt if there is an error.
    let mut classfiles = BTreeMap::<String, ClassFile>::new();
    for include_path in &args.classfiles {
        if let Err(why) = load_classfiles(&mut classfiles, include_path) {
            eprintln!("ERROR: {}", why);
            std::process::exit(FAILED_TO_LOAD_CLASSFILES);
        }
    }

    let mut diagram = if let Some(diagram_path) = &args.diagram {
        match load_mermaid(&diagram_path) {
            Ok(diagram) => diagram,
            Err(why) => {
                eprintln!("ERROR: {}", why);
                std::process::exit(FAILED_TO_LOAD_DIAGRAM);
            }
        }
    } else {
        Diagram::default()
    };

    let skip_annotation = args.skip.as_deref();
    let aggregate_annotation = args.aggregate.as_deref();
    let compose_annotation = args.compose.as_deref();
    let link_annotation = args.link.as_deref();
    let navigate_annotation = args.navigate.as_deref();

    // Collect all class names that need to be in the diagram
    let referenced_classes = collect_referenced_classes(&diagram);

    // Clear existing classes from namespaces (keep only relations and YAML)
    // We'll repopulate with full class details from classfiles
    diagram.namespaces.clear();

    // Determine if we should group by package
    let group_by_package = should_group_by_package(&diagram);

    // If grouping by package, find the common base package
    let base_package = if group_by_package {
        let full_names: Vec<String> = referenced_classes
            .iter()
            .filter_map(|class_name| classfiles.get(class_name))
            .filter_map(|classfile| get_full_class_name(classfile))
            .collect();

        let packages: Vec<&str> = full_names
            .iter()
            .map(|full_name| get_package_name(full_name))
            .filter(|pkg| !pkg.is_empty())
            .collect();

        find_common_base_package(&packages)
    } else {
        String::new()
    };

    // For each referenced class, populate it from the classfile if available
    for class_name in referenced_classes {
        // Try to find the corresponding classfile
        if let Some(classfile) = classfiles.get(&class_name) {
            // Check if the class itself has the skip annotation
            if classfile_utils::has_annotation(
                classfile.constant_pool(),
                classfile.attributes(),
                skip_annotation,
            ) {
                continue; // Skip this entire class
            }

            // Convert classfile to Mermaid class
            let mut mermaid_class =
                classfile_to_mermaid_class(classfile, &class_name, skip_annotation);

            // Determine the namespace for this class
            let namespace_name = if group_by_package {
                if let Some(full_class_name) = get_full_class_name(classfile) {
                    let package = get_package_name(&full_class_name);
                    get_relative_namespace(&base_package, package)
                } else {
                    mermaid_parser::types::DEFAULT_NAMESPACE.to_string()
                }
            } else {
                mermaid_parser::types::DEFAULT_NAMESPACE.to_string()
            };

            // Update the class's namespace field
            mermaid_class.namespace = namespace_name.clone();

            // Add the class to the appropriate namespace
            let namespace = diagram.namespaces.entry(namespace_name).or_default();

            namespace.classes.insert(class_name.clone(), mermaid_class);
        } else {
            // Class not found in classfiles - keep the stub if it exists
            eprintln!(
                "WARN: Class '{}' referenced in diagram but not found in classfiles",
                class_name
            );
        }

        // Serialize the diagram to Mermaid text
        let output_text = serialize_diagram(&diagram);

        // Determine output file path
        let default_name = || std::ffi::OsStr::new("output.mmd");
        let output_filename = args
            .diagram
            .as_ref()
            .map(|path| path.file_name().unwrap_or_else(default_name));
        let output_path = args
            .output
            .join(output_filename.unwrap_or_else(default_name));

        // Write to file
        if let Err(why) = fs::write(&output_path, output_text) {
            eprintln!(
                "ERROR: Failed to write output file {}: {}",
                output_path.display(),
                why
            );
            std::process::exit(FAILED_TO_WRITE_OUTPUT);
        }

        println!(
            "Successfully wrote linked diagram to {}",
            output_path.display()
        );
    }
}

#[cfg(test)]
mod tests {
    use crate::find_common_base_package;

    #[test]
    fn test_find_common_base_package() {
        let prefix = find_common_base_package(&[
            "com/MainActivity",
            "com/example/example/Helper",
            "com/example/Second",
        ]);

        assert_eq!("com", prefix);

        let prefix = find_common_base_package(&[
            "com/example/example/Helper",
            "com/example/Second",
            "com/example/Third",
        ]);

        assert_eq!("com/example", prefix);

        let prefix = find_common_base_package(&[
            "other/example/example/Helper",
            "com/example/Second",
            "com/example/Third",
        ]);

        assert_eq!("", prefix);
    }
}
