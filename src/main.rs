mod descriptor;
mod classfile_utils;
mod mermaid_output;

use anyhow::anyhow;
use clap::Parser;
use jclassfile::class_file::{self, ClassFile};
use mermaid_parser::types::Diagram;
use std::{
    collections::{BTreeMap, HashSet},
    fs,
    path::{Path, PathBuf},
};
use classfile_utils::classfile_to_mermaid_class;
use mermaid_output::serialize_diagram;

/// This program will take in a list of mermaid files which need "linking"
/// according to some list of targets.
#[derive(clap::Parser)]
pub struct Args {
    /// Some mermaid diagram file, generally containing relationships but
    /// can also have classes. These do not need to end with .mmd and will
    /// be assumed to have valid mermaid.
    target: Vec<PathBuf>,
    /// Files and folders to search for class definitions. Folders will be
    /// searched recursively any folder. These should be java class files.
    #[arg(short, long)]
    include: Vec<PathBuf>,
    /// Directory to write the final files to
    #[arg(short, long)]
    output: PathBuf,
    /// The fully qualified path of the skip annotation to optionally enable
    /// ommiting some types, fields, or methods. (e.g. `com.rocket.radar.Skip`)
    /// Note that this annotation must have a retention policy of RUNTIME
    /// or CLASS.
    #[arg(short, long)]
    skip: Option<String>,
}

#[derive(thiserror::Error, derive_more::From, Debug)]
enum LoadClassError {
    #[error("{0}")]
    Io(std::io::Error),
    #[error("{0}")]
    Parse(jclassfile::error::Error),
}

/// Helper to load a single classfile.
fn load_classfile(path: &Path) -> Result<ClassFile, LoadClassError> {
    let data = std::fs::read(path)?;
    Ok(class_file::parse(&data)?)
}

/// Load classfile for single file and all classfiles recursively if directory.
/// It will only load classfiles with a .class extension. If there is a file
/// with a .class extension which is not parseable as a classfile will issue a
/// warning and continue. All other errors will halt.
///
/// Note that this will skip loading the classfiles for anonymous classes. Such
/// as those generated by lambdas. (These are the classfiles whose names end with
/// $ and some number).
fn load_classfiles(
    store: &mut BTreeMap<String, ClassFile>,
    include_path: &Path,
) -> anyhow::Result<()> {
    if !include_path.exists() {
        return Err(anyhow!(
            "ERROR: Missing include path {}",
            include_path.display()
        ));
    }

    if include_path.is_dir() {
        for entry in include_path.read_dir()? {
            load_classfiles(store, &entry?.path())?;
        }
    } else if include_path.is_file() {
        if include_path
            .extension()
            .map(|ext| ext == "class")
            .unwrap_or(false)
        {
            let mut filestem = include_path
                .file_stem()
                .expect("If we have an ext we should have a stem")
                .to_string_lossy()
                .to_string();

            // Skip this classfile if it has an anonymous class
            if let Some((_, maybe_num)) = filestem.rsplit_once('$') {
                if maybe_num.chars().all(|ch| ch.is_numeric()) {
                    return Ok(());
                }
                // PERF: This is wasteful. We could do better.
                filestem = filestem.replace('$', "_");
            }

            match load_classfile(include_path) {
                Ok(classfile) => {
                    let old = store.insert(filestem, classfile);
                    assert!(old.is_none(), "All the class names should be unique");
                }
                Err(LoadClassError::Parse(why)) => {
                    eprintln!(
                        "WARN: Found an include file with extension .class but failed to parse `{}`\n{}",
                        include_path.display(),
                        why
                    );
                }
                Err(why) => return Err(why.into()),
            }
        }
    } else {
        return Err(anyhow!(
            "Passed an include path that pointed to a symlink ({})",
            include_path.display()
        ));
    }

    Ok(())
}

const FAILED_TO_LOAD_CLASSFILES: i32 = 1;
const FAILED_TO_LOAD_DIAGRAM: i32 = 2;
const FAILED_TO_WRITE_OUTPUT: i32 = 3;

#[derive(thiserror::Error, derive_more::From, Debug)]
enum LoadMermaidError {
    #[error("{0}")]
    Io(std::io::Error),
    #[error("{0}")]
    Parse(mermaid_parser::parser::ParseError),
}

fn load_mermaid(path: &Path) -> Result<mermaid_parser::types::Diagram, LoadMermaidError> {
    let link_content = fs::read_to_string(path)?;
    Ok(mermaid_parser::parser::parse(&link_content)?)
}

/// Collect all class names referenced in the diagram (from stubs and relations)
fn collect_referenced_classes(diagram: &Diagram) -> HashSet<String> {
    let mut referenced = HashSet::new();

    // Add all classes defined in the diagram
    for (_namespace_name, namespace) in &diagram.namespaces {
        for (class_name, _class) in &namespace.classes {
            referenced.insert(class_name.clone());
        }
    }

    // Add all classes referenced in relations
    for relation in &diagram.relations {
        referenced.insert(relation.from.clone());
        referenced.insert(relation.to.clone());
    }

    referenced
}

fn main() {
    let args = Args::parse();

    // Create output directory if it doesn't exist
    if !args.output.exists() {
        if let Err(why) = fs::create_dir_all(&args.output) {
            eprintln!("ERROR: Failed to create output directory: {}", why);
            std::process::exit(FAILED_TO_WRITE_OUTPUT);
        }
    }

    // Load all relevant classfiles and diagrams. We halt if there is an error.
    let mut classfiles = BTreeMap::<String, ClassFile>::new();
    for include_path in &args.include {
        if let Err(why) = load_classfiles(&mut classfiles, include_path) {
            eprintln!("ERROR: {}", why);
            std::process::exit(FAILED_TO_LOAD_CLASSFILES);
        }
    }

    let mut diagrams_with_paths = Vec::<(PathBuf, Diagram)>::with_capacity(args.target.len());
    for target_path in &args.target {
        match load_mermaid(target_path) {
            Ok(diagram) => diagrams_with_paths.push((target_path.clone(), diagram)),
            Err(why) => {
                eprintln!("ERROR: {}", why);
                std::process::exit(FAILED_TO_LOAD_DIAGRAM);
            }
        }
    }

    let skip_annotation = args.skip.as_deref();

    // Process each diagram
    for (target_path, mut diagram) in diagrams_with_paths {
        // Collect all class names that need to be in the diagram
        let referenced_classes = collect_referenced_classes(&diagram);

        // For each referenced class, populate it from the classfile if available
        for class_name in referenced_classes {
            // Try to find the corresponding classfile
            if let Some(classfile) = classfiles.get(&class_name) {
                // Convert classfile to Mermaid class
                let mermaid_class = classfile_to_mermaid_class(
                    classfile,
                    &class_name,
                    skip_annotation,
                );

                // Replace or add the class in the diagram
                // For simplicity, we'll work with the default namespace
                let namespace = diagram
                    .namespaces
                    .entry(mermaid_parser::types::DEFAULT_NAMESPACE.to_string())
                    .or_default();

                namespace.classes.insert(class_name.clone(), mermaid_class);
            } else {
                // Class not found in classfiles - keep the stub if it exists
                eprintln!("WARN: Class '{}' referenced in diagram but not found in classfiles", class_name);
            }
        }

        // Serialize the diagram to Mermaid text
        let output_text = serialize_diagram(&diagram);

        // Determine output file path
        let output_filename = target_path
            .file_name()
            .unwrap_or_else(|| std::ffi::OsStr::new("output.mmd"));
        let output_path = args.output.join(output_filename);

        // Write to file
        if let Err(why) = fs::write(&output_path, output_text) {
            eprintln!("ERROR: Failed to write output file {}: {}", output_path.display(), why);
            std::process::exit(FAILED_TO_WRITE_OUTPUT);
        }

        println!("Successfully wrote linked diagram to {}", output_path.display());
    }
}
